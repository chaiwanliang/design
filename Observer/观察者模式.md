## 观察者模式
### 一、什么是观察者模式
   > 观察者一般可以看做是第三者，比如在学校上自习的时候，大家肯定都有过交头接耳、各种玩耍的经历，
    这时总会有一个“放风”的小伙伴，当老师即将出现时及时“通知”大家老师来了。
    再比如，拍卖会的时候，大家相互叫价，拍卖师会观察最高标价，然后通知给其它竞价者竞价，这就是一个观察者模式。
    对于观察者模式而言，肯定有观察者和被观察者之分。比如在一个目录下建立一个文件，这时系统会通知目录管理器增加目录，
    并通知磁盘减少空间，在这里，文件就是观察者，目录管理器和磁盘就是被观察者。
    观察者模式（Observer），又叫发布-订阅模式（Publish/Subscribe），定义对象间一种一对多的依赖关系，
    使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。
    其中，Subject类是主题，它把所有对观察者对象的引用文件存在了一个聚集里，每个主题都可以有任何数量的观察者。
    抽象主题提供了一个接口，可以增加和删除观察者对象；Observer类是抽象观察者，为所有的具体观察者定义一个接口，
    在得到主题的通知时更新自己；ConcreteSubject类是具体主题，将有关状态存入具体观察者对象，在具体主题内部状态改变时，
    给所有登记过的观察者发出通知；ConcreteObserver是具体观察者，实现抽象观察者角色所要求的更新接口，
    以便使本身的状态与主题的状态相协同。 
   #### 1. 主题Subject
  > 首先定义一个观察者数组，并实现增、删及通知操作。它的职责很简单，就是定义谁能观察，谁不能观察，用Vector是线程同步的，
    比较安全，也可以使用ArrayList，是线程异步的，但不安全。
   #### 2. 抽象观察者Observer
  > 观察者一般是一个接口，每一个实现该接口的实现类都是具体观察者。
   #### 3. 具体主题
  > 继承Subject类，在这里实现具体业务，在具体项目中，该类会有很多变种。
   #### 4. 具体观察者
  > 实现Observer接口。
   #### 5. Client客户端
  > 首先创建一个被观察者，然后定义一个观察者，将该被观察者添加到该观察者的观察者数组中，进行测试。
### 二、观察者模式的应用
 * 1.何时使用
    > 一个对象状态改变，所有的依赖对象都将得到通知        
 * 2.方法
    > 使用面向对象技术
 * 3.优点
    > 观察者和被观察者是抽象耦合的
    建立了一套触发机制
 * 4.缺点
    > 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间
    如果观察者和观察目标间有循环依赖，可能导致系统崩溃
    没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的
 * 5.使用场景
    >关联行为场景
    事件多级触发场景
    跨系统的消息变换场景，如消息队列的处理机制
 * 6.应用实例
    > 手机丢了，委托别人给其他人发消息通知
    通知老师/老板来了
    拍卖，拍卖师观察最高标价，然后通知给其它竞价者竞价
    在一个目录下建立一个文件，会同时通知目录管理器增加目录，并通知磁盘减少空间，文件是被观察者，目录管理器和磁盘管理器是观察者
    猫叫了一声，吓着了老鼠，也惊到了主人，猫是被观察者，老鼠和人是观察者
 * 7.注意事项
    > 避免循环引用
    如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式


     
     