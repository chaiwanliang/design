## 工厂模式
   * 工厂类型分为三种，创建型模式，结构型模式，行为型模式。
   * 使用场景:
   >考虑一个简单的API设计，一个模块可以提供不同的APi,这些Api都源自同一个基类，
    不过在继承基类后不同的子类修改了部分属性,从而可以产生不同的功能实现，如果希望在使用这些Api时，
    只需要知道表示该api的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，
    此时，就可以使用简单工厂模式。
### 定义
   #### 简单工厂模式(Simple Factory Pattern)：
   > 又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。
     在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，
     被创建的实例通常都具有共同的父类。
     
   #### 组成角色
   * Factory：
     > 工厂角色工厂角色负责实现创建所有实例的内部逻辑
   * Product：抽象产品角色
     > 抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
     
   * ConcreteProduct：具体产品角色
     > 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。
 ### 注意：
  > golang在使用值传递时会为传入的值创建一个副本存储，所以该变量的地址会变，如果根据传入时的工厂模式的值进行取值，
    是取不到的，由于内存地址不同会造成内存泄漏。所以应该采取引用传递，只会为传入的指针创建一个副本，并不影响变量的地址更改
 ### 总结
  * 如何选择 T 和 *T
 > 不想变量被修改。 如果你不想变量被函数和方法所修改，那么选择类型T。相反，如果想修改原始的变量，则选择*T
   如果变量是一个大的struct或者数组，则副本的创建相对会影响性能，这个时候考虑使用*T，只创建新的指针，这个区别是巨大的
   (不针对函数参数，只针对本地变量／本地变量)对于函数作用域内的参数，如果定义成T,Go编译器尽量将对象分配到栈上，而*T很可能会分配到对象上，这对垃圾回收会有影响
   模式分析
   将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
 
 * 简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。
   简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象。
 
 * 简单工厂模式的优点
 > 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；
   简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
   客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
   通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。
 
 * 简单工厂模式的缺点
 > 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
   使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
   系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
   简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。
 
 * 适用环境
 > 在以下情况下可以使用简单工厂模式：
   工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
   客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。